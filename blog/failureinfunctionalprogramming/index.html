<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.68.3" />


<title>Using Monads for Handling Failures and Exceptions - Bayesian Statistics and Functional Programming </title>
<meta property="og:title" content="Using Monads for Handling Failures and Exceptions - Bayesian Statistics and Functional Programming ">



  








<link href='//cdn.bootcss.com/highlight.js/9.11.0/styles/tomorrow-night-eighties.min.css' rel='stylesheet' type='text/css' />



<link rel="stylesheet" href="/css/fonts.css" media="all">
<link rel="stylesheet" href="/css/main.css" media="all">



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="/" class="nav-logo">
    <img src="/images/picture_cropped.jpg"
         width="50"
         height="50"
         alt="Logo">
  </a>

  <ul class="nav-links">
    
    <li><a href="/about/">About</a></li>
    
    <li><a href="/blog/">Blog</a></li>
    
    <li><a href="https://github.com/jonnylaw">GitHub</a></li>
    
    <li><a href="https://twitter.com/lawsy">Twitter</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    <h1 class="article-title">Using Monads for Handling Failures and Exceptions</h1>

    

    <div class="article-content">
      


<p>In this post I will give a practical introduction to some useful structures for handling failure in functional programming.</p>
<div id="referential-transparency" class="section level2">
<h2>Referential Transparency</h2>
<p>One of the most important properties of functional programming is referential transparency and programming with pure functions. This means we can substitute a pure function with its result, for intance if we have the function <code>def f = 1 + 2</code>, we can replace every occurence of <code>f</code> with <code>3</code> and the final evaluation will remain unchanged</p>
<p>This simple idea can lead to difficulties when considering functions which involve side effects, such as reading from external sources or generating random numbers. One example of a side effect is an exception, an imperative programmer might write a function to calculate a square root as:</p>
<pre class="scala"><code>def unsafe_sqrt(a: Double): Double = {
  if (a &gt; 0) math.sqrt(a)
  else throw new Exception(&quot;Can&#39;t calculate square root of negative number&quot;)
}</code></pre>
<p>This compiles fine, however if we wrote this function for an end user and they didn’t look at the implementation they might not know the function can possibly return an exception.</p>
</div>
<div id="try" class="section level2">
<h2>Try</h2>
<p>In order to make it clear that a function can fail, we can return a <code>Try</code>:</p>
<pre class="scala"><code>def try_sqrt(a: Double): Try[Double] = {
  if (a &gt; 0) Success(math.sqrt(a))
  else Failure(throw new Exception(&quot;Can&#39;t calculate square root of negative number&quot;))
}</code></pre>
<p>Now, if someone were to use this function they would be forced to deal with the <code>Try</code> return type and understand that the function can return an exception. Try is actually an algebraic datatype (ADT), an illustrative implementation is:</p>
<pre class="scala"><code>sealed trait Try[+A]
case class Success[+A](a: A) extends Try[A]
case class Failure[+A](exception: Throwable) extends Try[A]</code></pre>
<p>This means that a <code>Try</code> can either be a <code>Success</code> or <code>Failure</code>. Learn more about <code>Try</code> in Daniel Westheide’s excellent <a href="http://danielwestheide.com/blog/2012/12/26/the-neophytes-guide-to-scala-part-6-error-handling-with-try.html">Neophyte’s Guide to Scala</a>.</p>
</div>
<div id="option" class="section level2">
<h2>Option</h2>
<p>Another simple structure to represent computations which may fail is <code>Option</code>, this is an algebraic datatype:</p>
<pre class="scala"><code>sealed trait Option[+A]
case class Some[+A](a: A) extends Option[A]
case class None extends Option[Nothing]</code></pre>
<p>In this case, option can either contain a value using the constructor <code>Some</code>, or can represent the absense of a value using <code>None</code>. This provides less information on failure that <code>Try</code>, but nevertheless is sometimes useful. We can re-write the <code>sqrt</code> function to return an optional value</p>
<pre class="scala"><code>def option_sqrt(a: Double): Option[Double] = {
  if (a &gt; 0) Some(math.sqrt(a))
  else None
}</code></pre>
<p>Now, when provide an incorrect argument to the function, we get <code>None</code> as the result.</p>
</div>
<div id="chaining-computations" class="section level1">
<h1>Chaining Computations</h1>
<p>In real world functional codebases we compose programs from many small functions. Let’s consider the problem of how to apply <code>def sqrt(a: Double): Option[Double]</code> twice. A naive attempt would be to simply compose the functions as we would for the Scala math library:</p>
<pre class="scala"><code>def sqrt_twice = unsafe_sqrt _ compose unsafe_sqrt _</code></pre>
<p>The <code>_</code> represents partial application of <code>unsafe_sqrt</code>, if we try to compose the <code>option_sqrt</code> function as in this example we will get a type mismatch. One application of <code>option_sqrt</code> returns a typle <code>Option[Double]</code>, but we need the type <code>Double</code>. Luckily <code>Option</code> has a function defined on it for composing operations like this:</p>
<pre class="scala"><code>def flatMap[A, B](a: Option[A])(f: A =&gt; Option[B]): Option[B]</code></pre>
<p>We can now use <code>flatMap</code> to compose <code>option_sqrt</code>:</p>
<pre class="scala"><code>def sqrt_twice_option(x: Double): Option[Double] = 
  option_sqrt(x) flatMap option_sqrt</code></pre>
<p>Now we can calculate <code>sqrt_twice_option(81) = Some(3.0)</code>.</p>
<p>We can compose <code>try_sqrt</code> in the same way:</p>
<pre class="scala"><code>def sqrt_twice_try(x: Double): Try[Double] = 
  try_sqrt(81) flatMap try_sqrt</code></pre>
<p>Now, what if we want to compose <code>option_sqrt</code> and <code>try_sqrt</code>. This is not an easy problem in general, however the Scala standard library implements a <code>toOption</code> method on <code>Try</code> values. Hence we can just convert the output of <code>try_sqrt</code> to an <code>Option</code>, however we lose the text from the exception upon failure, which could illuminating in the event of a failure. Let’s consider a more general way to compose the two.</p>
<div id="nested-maps" class="section level2">
<h2>Nested Maps</h2>
<p><code>Option</code> and <code>Try</code> are both monads (strictly <code>Try</code> is <a href="https://issues.scala-lang.org/browse/SI-6284">not a proper monad</a>), which means they are equipped with two methods which satisfy the monad laws. The two methods defined for all monads are:</p>
<pre class="scala"><code>trait Monad[A, M[_]] {
  def flatMap[B](f: A =&gt; M[B]): M[B]
  def pure(a: A): M[A]
}</code></pre>
<p>We can define all the functions on <code>Try</code> and <code>Option</code> using these two functions, for instance <code>map</code>:</p>
<pre class="scala"><code>def map[B](f: A =&gt; B): M[B] = this.flatMap(a =&gt; pure(f(a)))</code></pre>
<p>Now, we can use the <code>map</code> function to compose <code>option_sqrt</code> and <code>try_sqrt</code>:</p>
<pre class="scala"><code>def sqrt_twice(a: Double): Try[Option[Double]] = try_sqrt(a) map option_sqrt</code></pre>
<p>However, what if we want to apply another function to a value returned by this function:</p>
<pre class="scala"><code>def f(a: Double) = a + 1
sqrt_twice(81) map (_.map(f))
// Success(Some(4.0))</code></pre>
<p>We get the correct value, but we have to apply <code>map</code> twice, this seems cumbersome. There is a better way!</p>
</div>
<div id="monad-transformers" class="section level2">
<h2>Monad Transformers</h2>
<p>The functional programming library <a href="http://typelevel.org/cats/">cats</a>, short for category, has some built in types for dealing with nesting in a more elegent way. The type <code>OptionT[F[_], A]</code> can be used instead of <code>F[Option[A]]</code>, our <code>F[_]</code> type in this case is <code>Try[A]</code></p>
<pre class="scala"><code>import cats.implicits._
import cats.data.OptionT

def sqrt_twice_trans(a: Double): OptionT[Try, Double] = 
  OptionT.fromOption[Try](option_sqrt(a)) flatMap (b =&gt; OptionT.liftF(try_sqrt(b))</code></pre>
<p><code>OptionT</code> provides the function <code>fromOption</code> to transform the result of the <code>option_sqrt</code> function into the <code>OptionT</code> monad. The function <code>liftF</code> is used to lift any monad, in this case <code>Try</code> into the <code>OptionT</code> monad. This compiles and we if we now try to apply the function <code>def f(a: Double) = a + 1</code> to the result of this function we only need a single call to <code>map</code>. This is because <code>OptionT</code> is also a monad:</p>
<pre class="scala"><code>sqrt_twice_trans(81) map f
// OptionT(Success(Some(4.0)))</code></pre>
<p>This may seem like quite a lot of effort to remove a call to map, but removing unecessary duplication can help with readability of code, and enable bugs to be spotted earlier. The code has been assembled in a <a href="https://gist.github.com/jonnylaw/99460d466c84d9b52b57010d28b6a4f6">Github gist</a>.</p>
</div>
</div>

    </div>
  </article>

  


</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="/index.xml" type="application/rss+xml" target="_blank">RSS feed</a>
          </li>
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="/images/hugo-logo.png" width="22" height="22"></a>
          </li>
        </ul>
      </footer>

    </div>
    



<script src="//cdn.bootcss.com/highlight.js/9.11.0/highlight.min.js"></script>



<script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/r.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/yaml.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/scala.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



    

    
  </body>
</html>

