<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.68.3" />


<title>Seasonal DLM - Bayesian Statistics and Functional Programming </title>
<meta property="og:title" content="Seasonal DLM - Bayesian Statistics and Functional Programming ">



  








<link href='//cdn.bootcss.com/highlight.js/9.11.0/styles/tomorrow-night-eighties.min.css' rel='stylesheet' type='text/css' />



<link rel="stylesheet" href="/css/fonts.css" media="all">
<link rel="stylesheet" href="/css/main.css" media="all">



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="/" class="nav-logo">
    <img src="/images/picture_cropped.jpg"
         width="50"
         height="50"
         alt="Logo">
  </a>

  <ul class="nav-links">
    
    <li><a href="/about/">About</a></li>
    
    <li><a href="/blog/">Blog</a></li>
    
    <li><a href="https://github.com/jonnylaw">GitHub</a></li>
    
    <li><a href="https://twitter.com/lawsy">Twitter</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    <h1 class="article-title">Seasonal DLM</h1>

    

    <div class="article-content">
      


<div id="the-seasonal-dlm" class="section level2">
<h2>The Seasonal DLM</h2>
<p>I introduced the class of state space models called DLMs in a previous post covering the <a href="KalmanFilter/">Kalman Filter</a>. The seasonal DLM is similar to the first order DLM, however it incorporates a deterministic transformation to the state, in order to capture cyclic trends. Remember a general DLM can be written as:</p>
<p><span class="math display">\[\begin{align}
y_t &amp;= F_t x_t + \nu_t, \qquad \mathcal{N}(0, V_t), \\
x_t &amp;= G_t x_{t-1} + \omega_t, \quad \mathcal{N}(0, W_t).
\end{align}\]</span></p>
<p>In the fourier-form seasonal DLM, the state is transformed by a block diagonal matrix, <span class="math inline">\(G_t\)</span>, containing rotation matrices. The rotation matrix is given by:</p>
<p><span class="math display">\[R = \begin{pmatrix}
\cos(\omega) &amp; -\sin(\omega) \\
\sin(\omega) &amp; \cos(\omega)
\end{pmatrix},\]</span> where <span class="math inline">\(\omega\)</span> is the frequency of the seasonality. In practice, it is easier to specify the period of the seasonality, <span class="math inline">\(T\)</span>, which is related to the frequency: <span class="math inline">\(\omega = 2 \pi/T\)</span>. This means if we have data measured at hourly intervals and we believe the process has a daily cycle, then we will set <span class="math inline">\(T = 24\)</span>.</p>
<p>In order to model higher harmonics of the seasonality, we combine rotation matrices together into a block diagonal matrix, to form the <span class="math inline">\(G\)</span> matrix, for instance with 3 harmonics the system matrix is:</p>
<p><span class="math display">\[G = \begin{pmatrix}
\cos(\omega) &amp; -\sin(\omega) &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
\sin(\omega) &amp; \cos(\omega) &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; \cos(2\omega) &amp; -\sin(2\omega) &amp; 0&amp; 0 \\
0 &amp; 0 &amp; \sin(2\omega) &amp; \cos(2\omega) &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; \cos(3\omega) &amp; -\sin(3\omega) \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; \sin(3\omega) &amp; \cos(3\omega) \\
\end{pmatrix}.\]</span></p>
<p>In this case, the latent state, <span class="math inline">\(x_t\)</span> is six-dimensional. This means system evolution variance-covariance matrix, <span class="math inline">\(W_t\)</span> is a six by six matrix.</p>
<p>First we should make a <code>case class</code> in Scala representing a DLM. A <code>case class</code> in Scala is a class with a default <code>apply</code> method used to construct instances of the class. The <code>case class</code> also has getter methods which can be used to access the values of the class. The <code>case class</code> will be for a DLM with constant <span class="math inline">\(F\)</span> and <span class="math inline">\(G\)</span> matrices.</p>
<pre class="scala"><code>import breeze.linalg._

case class Dlm(f: DenseMatrix[Double], g: DenseMatrix[Double])</code></pre>
<p>Note that, for univariate observations <span class="math inline">\(F\)</span> will be a row vector, the recommended way to specify row vectors using <a href="https://github.com/scalanlp/breeze/">Breeze</a> is to use a matrix with a single row. The DLM also has associated parameters which we will assume are constant and write as a <code>case class</code>.</p>
<pre class="scala"><code>case class Parameters(v: Double, w: DenseMatrix[Double], m0: DenseVector[Double], c0: DenseMatrix[Double])</code></pre>
<p>Then we can add a method to simulate forward given a value of the <code>Parameters</code>, firstly we will write a single step of the simulation:</p>
<pre class="scala"><code>case class Data(time: Double, observation: Double, state: DenseVector[Double])

def simStep(p: Parameters, model: Dlm): Data =&gt; Rand[Data] = d =&gt; {
    for {
      w &lt;- MultivariateGaussian(DenseVector.zeros(p.w.cols), p.w)
      x1 = model.g * d.state + w
      v &lt;- Gaussian(0, p.v)
      y = model.f.toDenseVector dot x1 + v
    } yield Data(d.time + 1.0, y, x1)
  }</code></pre>
<p>This function contains a for comprehension, the <code>&lt;-</code> symbol represents either a <code>map</code> or a <code>flatMap</code>. Since the <code>w</code> and <code>v</code> are <code>Rand[Double]</code> values, we need to access the value inside of the <code>Rand</code> and perform a function on it, the for comprehension desugars to:</p>
<pre class="scala"><code>MultivariateGaussian(DenseVector.zeros(p.w.cols), p.w).
  flatMap(w =&gt; {
    val x1 = model.g * d.state + w
    Gaussian(0, p.v).map(v =&gt; {
      val y = model.f.toDenseVector dot x1 + v
      Data(d.time + 1.0, y, x1)
    })}
    )</code></pre>
<p>The desugared chain of <code>flatMap</code> and <code>map</code> evaluates to the same result, but the for-comprehension is more readable. This syntax provides a clean and elegent way to work within the context of a Monad, <code>Rand</code> is an example of a Monad representing a distribution.</p>
<p>Now, we can use the <code>MarkovChain</code> breeze object to simulate the full series:</p>
<pre class="scala"><code>def simMarkov(p: Parameters, model: Dlm): Rand[Process[Data]] = {
  for {
    x0 &lt;- MultivariateGaussian(p.m0, p.c0)
    y0 &lt;- Gaussian(model.f.toDenseVector dot x0, p.v)
    init = Data(0.0, y0, x0)
  } yield MarkovChain(init)(simStep(p, model))
}</code></pre>
<p>Note that the Markov chain is a <code>Rand[Process[Double]]</code>, this is not the most elegant and Iâ€™m open to suggestions on a better way to formulate this. Once we have defined a Markov chain, we must draw from it which returns a <code>Process[Double]</code>, the initial draw is to sample from the initial state distribution <span class="math inline">\(\mathcal{N}(m_0, C_0)\)</span>. Next, we can sample from the <code>Process</code> and plot it. A simulation from the seasonal DLM, with parameters <span class="math inline">\(V = 3\)</span> and <span class="math inline">\(W = I_6\)</span>, is given below:</p>
<p><img src="/blog/SeasonalDlm_files/figure-html/unnamed-chunk-1-1.png" width="672" /></p>
</div>

    </div>
  </article>

  


</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="/index.xml" type="application/rss+xml" target="_blank">RSS feed</a>
          </li>
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="/images/hugo-logo.png" width="22" height="22"></a>
          </li>
        </ul>
      </footer>

    </div>
    



<script src="//cdn.bootcss.com/highlight.js/9.11.0/highlight.min.js"></script>



<script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/r.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/yaml.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/scala.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



    
<script src="/js/math-code.js"></script>
<script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    
  </body>
</html>

