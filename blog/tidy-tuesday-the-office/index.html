<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.68.3" />


<title>Tidy Tuesday: The Office - Bayesian Statistics and Functional Programming </title>
<meta property="og:title" content="Tidy Tuesday: The Office - Bayesian Statistics and Functional Programming ">



  








<link href='//cdn.bootcss.com/highlight.js/9.11.0/styles/tomorrow-night-eighties.min.css' rel='stylesheet' type='text/css' />



<link rel="stylesheet" href="/css/fonts.css" media="all">
<link rel="stylesheet" href="/css/main.css" media="all">



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="/" class="nav-logo">
    <img src="/images/picture_cropped.jpg"
         width="50"
         height="50"
         alt="Logo">
  </a>

  <ul class="nav-links">
    
    <li><a href="/about/">About</a></li>
    
    <li><a href="/blog/">Blog</a></li>
    
    <li><a href="https://github.com/jonnylaw">GitHub</a></li>
    
    <li><a href="https://twitter.com/lawsy">Twitter</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    <h1 class="article-title">Tidy Tuesday: The Office</h1>

    

    <div class="article-content">
      


<p>First we download the ratings for each office episode using the <a href="https://github.com/rfordatascience/tidytuesday/">tidytuesdayR</a> package.</p>
<pre class="r"><code>office &lt;- tidytuesdayR::tt_load(x = 2020, 12)
episode_ratings &lt;- office$office_ratings</code></pre>
<p>We can use <code>glimpse</code> from the tibble package to see the column types and some example data from the head of the table.</p>
<pre class="r"><code>glimpse(episode_ratings)</code></pre>
<pre><code>## Observations: 188
## Variables: 6
## $ season      &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, …
## $ episode     &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, …
## $ title       &lt;chr&gt; &quot;Pilot&quot;, &quot;Diversity Day&quot;, &quot;Health Care&quot;, &quot;The Alliance&quot;, …
## $ imdb_rating &lt;dbl&gt; 7.6, 8.3, 7.9, 8.1, 8.4, 7.8, 8.7, 8.2, 8.4, 8.4, 8.2, 8.…
## $ total_votes &lt;dbl&gt; 3706, 3566, 2983, 2886, 3179, 2852, 3213, 2736, 2742, 271…
## $ air_date    &lt;date&gt; 2005-03-24, 2005-03-29, 2005-04-05, 2005-04-12, 2005-04-…</code></pre>
<p>Firstly, I will plot the distribution of ratings by season. We can see that the ratings dropped after season 8 when Steve Carell left the show.</p>
<pre class="r"><code>episode_ratings %&gt;%
  group_by(season) %&gt;%
  tidybayes::median_qi(imdb_rating, .width = c(0.6, 0.9)) %&gt;%
  ggplot(aes(x = as.factor(season), y = imdb_rating)) +
  tidybayes::geom_pointinterval() +
  labs(
    title = &quot;Office (US) IMDB Ratings by Season&quot;,
    subtitle = &quot;The point interval shows the median, 60% and 90% intervals.&quot;,
    x = &quot;Season&quot;,
    y = &quot;IMDB Rating&quot;
  )</code></pre>
<p><img src="/blog/tidy-tuesday-the-office_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<p>Using the <a href="https://bradlindblad.github.io/schrute/">schrute package</a> we can get every line of dialogue and additional episode information including the writers and the directors.</p>
<pre class="r"><code>script &lt;- schrute::theoffice</code></pre>
<p>Next, I wanted to see the number of episodes per writer.</p>
<pre class="r"><code>writers &lt;- script %&gt;% 
  mutate_at(vars(season, episode), as.numeric) %&gt;% 
  inner_join(episode_ratings, by = c(&quot;season&quot;, &quot;episode&quot;)) %&gt;% 
  separate(writer, into = paste0(&quot;writer&quot;, 1:3), sep = &quot;;&quot;) %&gt;% 
  select(season, episode, episode_name, imdb_rating, contains(&quot;writer&quot;)) %&gt;% 
  distinct() %&gt;% 
  pivot_longer(contains(&quot;writer&quot;), names_to = &quot;name&quot;, values_to = &quot;writer&quot;) %&gt;% 
  drop_na() %&gt;% 
  mutate(true = TRUE) %&gt;% 
  pivot_wider(names_from = writer, values_from = true) %&gt;% 
  mutate_if(is.logical, ~ !is.na(.)) %&gt;% 
  group_by(season, episode, episode_name, imdb_rating) %&gt;% 
  summarise_if(is.logical, sum)

episodes_per_writer &lt;- writers %&gt;%
  ungroup() %&gt;%
  select(-c(1:4)) %&gt;%
  summarise_all(sum) %&gt;%
  gather(key = writer, value = total_episodes)

episodes_per_writer %&gt;% 
  mutate(writer = forcats::fct_reorder(writer, total_episodes)) %&gt;%
  ggplot(aes(x = total_episodes, y = writer)) +
  geom_col() +
  labs(title = &quot;Number of episodes by writer&quot;, 
       y = &quot;Writer&quot;, x = &quot;Total Episodes&quot;)</code></pre>
<p><img src="/blog/tidy-tuesday-the-office_files/figure-html/unnamed-chunk-5-1.png" width="480" /></p>
<p>Next, I would like to see which writers produce the highest rated episodes. Determining the writer who writes the best episodes is challenging since writers often collaborate and some writers have only written a handful of episodes. Initially I plotted the IMDB rating for each episode written by each writer regardless of who they collaborated with.</p>
<p>Steve Carell appears to have the highest median episode rating, however he has written only two episodes! It looks like Greg Daniels is the real MVP, with many consistently well received episodes.</p>
<pre class="r"><code>writers_by_episode &lt;- writers %&gt;% 
  ungroup() %&gt;% 
  pivot_longer(-c(1:4), names_to = &quot;writer&quot;, values_to = &quot;written&quot;) %&gt;% 
  filter(written == 1) 

writers_by_episode %&gt;% 
  mutate(writer = forcats::fct_reorder(writer, imdb_rating)) %&gt;%
  ggplot(aes(x = imdb_rating, y = writer)) +
  geom_point()</code></pre>
<p><img src="/blog/tidy-tuesday-the-office_files/figure-html/unnamed-chunk-6-1.png" width="480" /></p>
<pre class="r"><code># ggsave(&quot;ratings_by_writer.png&quot;, width = 5, height = 8)</code></pre>
<div id="a-model-for-writers" class="section level2">
<h2>A Model for Writers</h2>
<p>We could fit a hierarchical model to the rating by writer using the <a href="https://paul-buerkner.github.io/brms/">BRMS</a> package which uses <a href="https://mc-stan.org">Stan</a> to perform full Bayesian inference for hierarchical distributional models. The hierarchical model allows the ratings to be shared across writers, hence writers with a small number of episode credits will be pulled towards the overall mean rating of all episodes. The model specification can be written as</p>
<p><span class="math display">\[\begin{aligned}
\mathbf{Y} &amp;\sim \textrm{Beta}(\mu\phi, (1 - \mu)\phi), \\
\mu &amp;= \mathbf{X}\beta + \mathbf{Z}\nu, \\
p(\beta) &amp;= \mathcal{N}(0, 5^2) \\
p(\nu) &amp;= \mathcal{N}(0, \sigma^2) \\
p(\sigma) &amp;= \frac{1}{2}t(3, 0, 10) \\
p(\phi) &amp;= \textrm{Gamma}(0.01, 0.01).
\end{aligned}\]</span></p>
<p>Where <span class="math inline">\(Y\)</span> represents the scaled IMDB rating (<span class="math inline">\(Y = \textrm{IMDB Rating} / 10\)</span>). The parameters we wish to estimate include <span class="math inline">\(\beta\)</span>, which is the latent population-level effect and <span class="math inline">\(\nu\)</span> which is the latent group-level effect. The Beta distribution has support in <span class="math inline">\([0, 1]\)</span> so the ratings are scaled by dividing by ten. We can recover the true scale by multiplying by 10 when considering the posterior fitted values. The response Beta distribution is parameterised such that the mean is <span class="math inline">\(\mu\)</span> and the variance is <span class="math inline">\(\operatorname{Var}(Y) = \mu(1-\mu)/(1+\phi)\)</span> so the variance of the response decreases as <span class="math inline">\(\phi\)</span> increases, <span class="math inline">\(\phi\)</span> is known as a precision parameter for the Beta distribution. The design matrix <span class="math inline">\(X\)</span> contains the intercept representing the overall mean IMDB rating. The design matrix <span class="math inline">\(Z\)</span> is a matrix containing ones.</p>
<p>There are 40 group level effects, drawn from a Normal distribution with standard deviation <span class="math inline">\(\sigma\)</span>. <span class="math inline">\(\sigma\)</span> has a half student-t prior which controls the regularisation of the group level effects. Effectively the level of regularisation for the group level effects is learned from the data. The <a href="https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations">Stan wiki</a> provides a good reference to the literature on prior choices.</p>
<p>First rescale the rating to be between zero and one.</p>
<pre class="r"><code>model_data &lt;- writers_by_episode %&gt;% 
  mutate(rating = imdb_rating / 10)</code></pre>
<p>To define and fit the model use the <code>brm</code> function. The formula <code>rating ~ (1 | writer)</code> specified that we want a group-level effect for each writer. The population level intercept is included by default. The response <code>family</code> is specified to be the Beta distribution and the prior distribution for the population intercept is specified as a Normal distribution with mean 0 and standard deviation 5. The other priors are default and specified above.</p>
<pre class="r"><code>fit &lt;- brm(rating ~ 1 + (1 | writer), family = Beta, data = model_data, prior = set_prior(&quot;normal(0, 5)&quot;, class = &quot;Intercept&quot;))</code></pre>
<p>The model is fit using Hamiltonian Monte Carlo, the sampling code is written in C++. If you are familiar with Stan, you can extract the Stan code from the model using <code>stancode(fit)</code>.</p>
<p>Next we plot the posterior fitted values using the <a href="https://mjskay.github.io/tidybayes/">tidybayes package</a> and overlay the actual episode ratings using points. Those with fewer writing credits have a larger posterior credible interval.</p>
<pre class="r"><code>add_fitted_draws(newdata = model_data, model = fit) %&gt;%
  mutate(fitted_rating = .value * 10) %&gt;%
  median_qi(fitted_rating, .width = c(.95, .8, .5)) %&gt;%
  ungroup() %&gt;%
  mutate(writer = forcats::fct_reorder(writer, fitted_rating)) %&gt;%
  ggplot(aes(y = writer, x = fitted_rating)) +
  geom_intervalh() +
  geom_point(aes(x = imdb_rating), data = writers_by_episode) +
  scale_color_brewer() +
  labs(
    title = &quot;Posterior Fitted Values for IMDB Rating Ordered by Posterior Mean&quot;,
    subtitle = &quot;Actual episode ratings are plotted as points&quot;,
    x = &quot;IMDB Rating&quot;,
    y = &quot;&quot;
  ) +
  theme(legend.position = &quot;none&quot;) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())</code></pre>
<p><img src="/blog/tidy-tuesday-the-office_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
<pre class="r"><code># ggsave(&quot;brms_ratings_by_writer.png&quot;, width = 7, height = 8)</code></pre>
</div>
<div id="tweet" class="section level1">
<h1>Tweet</h1>
<p>Now use the <a href="https://rtweet.info/">rtweet</a> library to post the plots directly to Twitter without leaving R. You must connect to the Twitter API using OAuth as described in <a href="https://rtweet.info/articles/auth.html">this vignette</a>, I set the Twitter application keys in my <code>.Renviron</code> file which is never committed to public version control (this can be easily edited using <code>usethis::edit_r_environ()</code>).</p>
<pre class="r"><code>library(rtweet)

token &lt;- create_token(
  app = &quot;rstats&quot;,
  consumer_key = Sys.getenv(&quot;TWITTER_API_KEY&quot;), 
  consumer_secret = Sys.getenv(&quot;TWITTER_API_SECRET_KEY&quot;),
  access_token = Sys.getenv(&quot;TWITTER_ACCESS_TOKEN&quot;),
  access_secret = Sys.getenv(&quot;TWITTER_ACCESS_TOKEN_SECRET&quot;))</code></pre>
<p>The function <code>post_tweet</code> can be used to post a new tweet.</p>
<pre class="r"><code>post_tweet(
  status = &quot;This week&#39;s #TidyTuesday data is from the US Office TV series. I&#39;ve fit a simple Bayesian hierarchical model using Stan and BRMS to determine which writers produce the highest rated episodes. Full code: https://jonnylaw.rocks/blog/tidy-tuesday-the-office/ #rstats&quot;,
  media = c(&quot;brms_ratings_by_writer.png&quot;, &quot;ratings_by_writer.png&quot;),
  token = token
)</code></pre>
</div>

    </div>
  </article>

  


</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="/index.xml" type="application/rss+xml" target="_blank">RSS feed</a>
          </li>
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="/images/hugo-logo.png" width="22" height="22"></a>
          </li>
        </ul>
      </footer>

    </div>
    



<script src="//cdn.bootcss.com/highlight.js/9.11.0/highlight.min.js"></script>



<script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/r.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/yaml.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/scala.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



    
<script src="/js/math-code.js"></script>
<script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    
  </body>
</html>

